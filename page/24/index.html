<!doctype html><html lang=ja dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>My Hugo Blog</title><meta name=description content="Blog"><meta name=author content><link rel=canonical href=https://ny-a.github.io/hugo-blog/><link crossorigin=anonymous href=/hugo-blog/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><link rel=icon href=https://ny-a.github.io/hugo-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ny-a.github.io/hugo-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ny-a.github.io/hugo-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://ny-a.github.io/hugo-blog/apple-touch-icon.png><link rel=mask-icon href=https://ny-a.github.io/hugo-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><link rel=alternate type=application/rss+xml href=https://ny-a.github.io/hugo-blog/index.xml><meta property="og:title" content="My Hugo Blog"><meta property="og:description" content="Blog"><meta property="og:type" content="website"><meta property="og:url" content="https://ny-a.github.io/hugo-blog/"><meta name=twitter:card content="summary"><meta name=twitter:title content="My Hugo Blog"><meta name=twitter:description content="Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"My Hugo Blog","url":"https://ny-a.github.io/hugo-blog/","description":"Blog","thumbnailUrl":"https://ny-a.github.io/hugo-blog/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ny-a.github.io/hugo-blog/ accesskey=h title="My Hugo Blog (Alt + H)">My Hugo Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ny-a.github.io/hugo-blog/archives title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>DNSSECの設定をしました</h2></header><section class=entry-content><p>クライアント側もドメイン側も、設定するだけで DNSSEC が使える状態になっていたので、両方とも設定して DNSSEC を有効にしてみました。
クライアント設定 DNS リゾルバは systemd-resolved を使っているので、 DNSSEC 対応の DNS サーバーが使われていれば DNSSEC が有効になります。 1.1.1.1 や 8.8.8.8 は DNSSEC に対応しています。 しかし、ルーターなどが提供するリゾルバは対応していないことが多いので、それをデフォルトで使っていて無効になっていました。 1.1.1.1 を直接使うように設定するには、 /etc/systemd/resolved.conf に以下の行を追加します。
DNS=1.1.1.1
あとは sudo systemctl restart systemd-resolve を実行して、 systemd-resolved サービスを再起動すれば有効になります。
有効になっていれば、 resolvectl query sigfail.verteiltesysteme.net を実行すると invalid とエラーが出るはずです。
ドメインの設定 DNSSEC対応の独自ドメインを年額$0.88で運用できるよという話 を見ると、海外のレジストラは DNSSEC に対応しているところが多いようです。 私の使っている nyaw.dev は Gandi で取得したため、ボタン1つで有効化することができました。
nyaw.dev - dnsviz を確認すると、正常に設定されていることが確認できます。
といっても、リダイレクトさせているのであんまり嬉しくはないんですが……。
ブログだけではなくポートフォリオも含めてページを充実させていって、ドメイン設定もきちんとしていこうと思っています。</p></section><footer class=entry-footer>February 27, 2020&nbsp;·&nbsp;1 分</footer><a class=entry-link aria-label="post link to DNSSECの設定をしました" href=https://ny-a.github.io/hugo-blog/posts/2020-02/set-up-dnssec/></a></article><article class=post-entry><header class=entry-header><h2>Xorgの仮想ディスプレイについて調べました</h2></header><section class=entry-content><p>Linux デスクトップで、他のデバイスを VNC などを使って仮想的にワイアレスディスプレイとして使うために、 仮想ディスプレイを追加する方法を調べました。
余っているディスプレイ出力を使う [SOLVED] Creating a Virtual Display/monitor - Arch Forum を見ると、余っている(ディスプレイを接続していない)ディスプレイ出力を使用して仮想ディスプレイを作成することができるようです。 ディスプレイを接続して表示している状態で切断した状態と同じだと思います。
ただ、前回これを使って VNC で接続した場合、リフレッシュレートがかなり下がってしまっていた記憶があるため、 他の方法を探してみました。
VIRTUAL1を作成する Add VIRTUAL output to Xorg - Stack Exchange を見てみると、 intel ドライバを使って VirtualHeads を作成することができるようです。
sudo pacman -S xf86-video-intel cat &lt;&lt;EOH | sudo tee /etc/X11/xorg.conf.d/20-intel-virtual-heads.conf Section "Device" Identifier "intelgpu0" Driver "intel" Option "VirtualHeads" "2" EndSection EOH Xorg を再起動すると、output として VIRTUAL1 が追加されています。
ただ、 Intel Graphics - Arch Wiki に書かれていますが、 xf86-video-intel は非推奨扱いになっていて、標準の modesetting ドライバが推奨されているようです。...</p></section><footer class=entry-footer>February 26, 2020&nbsp;·&nbsp;1 分</footer><a class=entry-link aria-label="post link to Xorgの仮想ディスプレイについて調べました" href=https://ny-a.github.io/hugo-blog/posts/2020-02/virtual-heads-of-xf86-video-intel/></a></article><article class=post-entry><header class=entry-header><h2>EC2にECDSAのキーを使ってSSHできるようにしました</h2></header><section class=entry-content><p>AWS のキーペアは RSA しか対応していないと思いますが、最近は RSA を使うこともかなり減っていて、新しくセットアップした PC などでは ECDSA/Ed25519 のキーしか作っていないこともあります。 そこで、 UserData を使って普段使いの SSH キーを取得して SSH できるようにしました。
UserData AmazonLinux2 を使っているので、ログインユーザーは ec2-user です。
UserData を以下のようにします。
#!/bin/bash set -eu curl https://github.com/ny-a.keys >> /home/ec2-user/.ssh/authorized_keys AmazonLinux に入っている OpenSSH のバージョンが古くて RSA にしか対応していないわけではないので、 authorized_keys に入れてあげさえすれば使うことができます。
AWS のキーペアで管理しないため、本番環境などでは何か問題があるかも……とは思いますが、普段使いのキーを使える上に、 普段使いのキーを更新したあとに起動したインスタンスは新しいキーを使えるようになるので、利便性は高いんじゃないかなと 思います。
とりあえず、開発中などはこのようにすると便利そうだと思いました。</p></section><footer class=entry-footer>February 25, 2020&nbsp;·&nbsp;1 分</footer><a class=entry-link aria-label="post link to EC2にECDSAのキーを使ってSSHできるようにしました" href=https://ny-a.github.io/hugo-blog/posts/2020-02/use-ecdsa-key-on-ec2/></a></article><article class=post-entry><header class=entry-header><h2>AWS CLIでAssumeRole</h2></header><section class=entry-content><p>AWS のアカウントを CLI から操作することが多いので credentials を保存しているのですが、 権限を多く持ったユーザーの認証情報を持っておくのは少し不安になったので、 AssumeRole を使って普段はあまり権限を 持たないユーザーの認証情報を持っておくことにしました。
方法 方法は How do I assume an IAM role using the AWS CLI? に書いてある通りです。
AssumeRole 時に MFA を要求するように設定することもできます。
また、 Using an IAM Role in the AWS CLI に記載のあるように、 AWS CLI では --profile オプションで指定することにより、自動で簡単に AssumeRole を 使用することができます。
MFA を併用することで、 TOTP をパスワードとした sudo のような操作も可能になります。 また、検証環境と本番環境のロールを分けるといったことも考えられます。 誤操作を防ぎ、安全性を高められると思うので、このような機能は積極的に使っていこうと思いました。</p></section><footer class=entry-footer>February 24, 2020&nbsp;·&nbsp;1 分</footer><a class=entry-link aria-label="post link to AWS CLIでAssumeRole" href=https://ny-a.github.io/hugo-blog/posts/2020-02/aws-cli-assume-role/></a></article><article class=post-entry><header class=entry-header><h2>/dev/randomが遅かったので高速化を試してみました</h2></header><section class=entry-content><p>ArchLinux をインストールしているノート PC に rng-tools をインストールして、 初期設定の状態で rngd.service を起動していたのですが、乱数生成が遅く感じたので調べてみました。
乱数生成の速度計測 乱数生成の速度の計測は以下のコマンドで行いました。
sudo dd if=/dev/random of=/dev/null bs=1 count=1000000 iflag=fullblock status=progress この結果が、前から使っているノート PC では 400kB/s 程度出ていて、 Rng-tools - ArchWiki では 50kB/s 程度出ていれば問題ないと書かれていますが、 新しい方のノート PC では 4kB/s 程度でした。
/dev を確認してみると、 /dev/hwrng は存在して、 rngd もそれを認識して正常に使用しているようでした。 搭載している tpm は 2.0 で、特に tpm 関連のエラーも出ていません。 また、 lscpu で確認すると、 rdrand rdseed 両方のフラグが立っています。
rngd のソースの優先順位 rngd(8) の Entropy_Source を見ると、
hwrng tpm rdrand darn nist jitter pkcs11 の順で使用するようです。...</p></section><footer class=entry-footer>February 23, 2020&nbsp;·&nbsp;1 分</footer><a class=entry-link aria-label="post link to /dev/randomが遅かったので高速化を試してみました" href=https://ny-a.github.io/hugo-blog/posts/2020-02/hwrng-is-slow/></a></article><article class=post-entry><header class=entry-header><h2>nftablesでdockerを使ってみました</h2></header><section class=entry-content><p>Linux 3.13 から利用可能な、 iptables を置き換える(ことを目的とした)パケット分類フレームワークの(ファイアーウォール？) nftables を、 docker を使っている環境で使ってみました。
インストール・有効化 Docker から使うには、 iptables の互換フロントエンドをインストールする必要があります。 nftables と一緒にインストールするには、以下を実行します。 (iptables-nft は iptables を置き換えます。)
sudo pacman -S nftables iptables-nft nftables.service を起動すると、 /etc/nftables.conf から設定を読み込みます。 起動・自動的に起動するようにするには、以下を実行します。
sudo systemctl enbale --now nftables ArchLinux の nftables パッケージの etc/nftables.conf には、 シンプルでセキュアなファイアーウォールが設定されています。 1:0.9.3-1 時点での設定内容は以下の通りです。
#!/usr/bin/nft -f # ipv4/ipv6 Simple & Safe Firewall # you can find examples in /usr/share/nftables/ table inet filter { chain input { type filter hook input priority 0; # allow established/related connections ct state {established, related} accept # early drop of invalid connections ct state invalid drop # allow from loopback iifname lo accept # allow icmp ip protocol icmp accept ip6 nexthdr icmpv6 accept # allow ssh tcp dport ssh accept # everything else reject with icmpx type port-unreachable } chain forward { type filter hook forward priority 0; drop } chain output { type filter hook output priority 0; } } # vim:set ts=2 sw=2 et: Docker を使用するための設定 標準のままだと、 Docker コンテナとの通信は forward チェインのルールにより drop されてしまいます。 docker エンジンによって作成される DOCKER-USER チェインのパケットを accept するには、以下のコマンドを実行します。...</p></section><footer class=entry-footer>February 22, 2020&nbsp;·&nbsp;3 分</footer><a class=entry-link aria-label="post link to nftablesでdockerを使ってみました" href=https://ny-a.github.io/hugo-blog/posts/2020-02/nftables-with-docker/></a></article><article class=post-entry><header class=entry-header><h2>XRandRが自動で解像度を変えてくれると思ったら勘違いでした</h2></header><section class=entry-content><p>Linux でマルチモニタ環境で使用する場合、モニタの設定は xrandr などを使って行いますが、 解像度の高い設定にしている状態でケーブルを抜き、解像度の低いモニタに接続した場合、 前は割とひどいことになったような気がしていたのですが、今試したところ最適な感じで縮小されて 表示されたので、動作を調べてみました。
既にタイトルに書いてある通りこれは勘違いで、 xrandr は設定してある解像度で出力しているだけで、 モニタ側が自動で縮小してくれていたようでした。 モニタで縮小していても、 xrandr --output DP-1 --scale-from 1920x1080 のように xrandr で縮小しても、 見た目は変わらないので……。
全部 FullHD のモニタで統一すれば何も問題はないですが、現状そうなってはいないので…… まあモニタの接続を変更することは基本的にないので、出先等で何かする場合以外は特に問題になることもなさそうではあります。</p></section><footer class=entry-footer>February 21, 2020&nbsp;·&nbsp;1 分</footer><a class=entry-link aria-label="post link to XRandRが自動で解像度を変えてくれると思ったら勘違いでした" href=https://ny-a.github.io/hugo-blog/posts/2020-02/xrandr-changes-resolution/></a></article><article class=post-entry><header class=entry-header><h2>RootKeySigningKeyCeremonyの延期</h2></header><section class=entry-content><p>DNSSEC の Root KSK Ceremony が、金庫が開かなくなったため延期されていたようです。
Rescheduling Root KSK Ceremony 40 で告知されていますが、 @joao_damas さんのツイート で写真を見ると分かりやすいですね。
IANA のサイト では、延期されたセレモニーの動画を見ることができます。 HSM を使っていたり、かなり厳重なセキュリティを確保しているのが分かりました。</p></section><footer class=entry-footer>February 20, 2020&nbsp;·&nbsp;1 分</footer><a class=entry-link aria-label="post link to RootKeySigningKeyCeremonyの延期" href=https://ny-a.github.io/hugo-blog/posts/2020-02/rescheduling-root-ksk-ceremony-40/></a></article><article class=post-entry><header class=entry-header><h2>ターミナルの色をAppSignalベースに変更しました</h2></header><section class=entry-content><p>ターミナルエミュレータは rxvt-unicode を使っていて、デフォルトの白背景で使っているのですが、 黄色の文字がどうにも見えなくて困っていました。
ターミナルの基本的な ANSI escape sequence に対応する色は ANSI_escape_code - Wikipedia に一覧があります。 rxvt-unicode は xterm のものとほぼ同じようです。
白背景で見やすい色の組み合わせを探してみたところ、 jeffkreeftmeijer/appsignal.terminal が白背景でも黒背景でも見やすく感じたため、試してみました。
itermcolors は XML で RGB それぞれ 0-1 の実数値で表現されているようなので、きっと先人が hex に変換するスクリプトを 公開しているはずです。 Gist にありましたが、 Color Space が入っているものに対応していないようだったので、少し修正して Gist に公開しておきました。
さて、基本は上記スクリプトで変換して Xresources に設定するだけですが、赤だったところが青になったり、少し違和感を 感じました。そこで、色の対応を似ているものに変更してみました。
URxvt.color0: #463f31 URxvt.color4: #3316c3 URxvt.color2: #50af4c URxvt.color6: #04aaef URxvt.color5: #c46109 URxvt.color1: #8f0c8a URxvt.color3: #8a7d06 URxvt.color7: #c5beb0 URxvt.color8: #5f584a URxvt.color12: #7255ff URxvt.color10: #8fee8b URxvt.color14: #43e9ff URxvt.color13: #ffa048 URxvt.color9: #ce4bc9 URxvt....</p></section><footer class=entry-footer>February 19, 2020&nbsp;·&nbsp;1 分</footer><a class=entry-link aria-label="post link to ターミナルの色をAppSignalベースに変更しました" href=https://ny-a.github.io/hugo-blog/posts/2020-02/terminal-color-from-appsignal/></a></article><article class=post-entry><header class=entry-header><h2>OpenSSH8.2でFIDO2を試しました</h2></header><section class=entry-content><p>といってもキーの生成だけですが……
とりあえず手元にある古い(？) Yubikey を使って ecdsa-sk のキーの生成ができることを確認してみます。
$ ssh-keygen -t ecdsa-sk -b 521 Generating public/private ecdsa-sk key pair. You may need to touch your authenticator to authorize key generation. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in ... Your public key has been saved in ... The key fingerprint is: SHA256:LHym5H0zQ6tvRXNZp/bMEUy7F1WN6tUicAGJMjxSOZQ ... The key's randomart image is: +-[ECDSA-SK 256]--+ | +oo ..o..oo=| | ....</p></section><footer class=entry-footer>February 18, 2020&nbsp;·&nbsp;1 分</footer><a class=entry-link aria-label="post link to OpenSSH8.2でFIDO2を試しました" href=https://ny-a.github.io/hugo-blog/posts/2020-02/tried-openssh-8-2-fido/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ny-a.github.io/hugo-blog/page/23/>« 前のページ</a>
<a class=next href=https://ny-a.github.io/hugo-blog/page/25/>次のページ »</a></nav></footer></main><footer class=footer><span>&copy; 2021 <a href=https://ny-a.github.io/hugo-blog/>My Hugo Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>